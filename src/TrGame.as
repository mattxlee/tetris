package  {		import flash.display.MovieClip;	import flash.display3D.IndexBuffer3D;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.TimerEvent;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.utils.Timer;		[SWF(width="500",height="550")]
		public class TrGame extends MovieClip implements ITrGameData {				// number of columns and rows		private var col:Number = 10;		private var row:Number = 20;		private var values:Array;		private var nextBlockIndex:Number;				// scores and etc.		private var score:Number;		private var totalRemovedLines:Number;		private var level:Number;		private var gameOver:Boolean;		private var isPaused:Boolean;		private var isFlashing:Boolean = false;				private var blockDrawer:TrBlockDrawer;		private var currentBlocks:ITrBlocks;		// timer for droping blocks		private var timer:Timer;				// timer for flash		private var flashingTimer:Timer;		private var flashingLines:Array; // stores the line number of full lines which will be flashing		private var flashingLinesValue:Array; // stores the values of the flashing lines		private var currentFlashIndex:Number;		private var numberOfFlashTimes:Number = 3;				// all shapes we have, class of TrAbstractBlocks		private var blockShapes:Array;				// text fields		private var scoreLabel:TextField;		private var levelLabel:TextField;		private var nextBlockLabel:TextField;		private var infoLabel:TextField;				// flash size		private var flashWidth:Number;		private var flashHeight:Number;				/********************************************** constructor and initializators ********************************************************/				public function TrGame() {									// keyboard event receiver			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);			blockDrawer = new TrBlockDrawer(graphics);						// 7 shapes			initializeShapes();			nextBlockIndex = Math.floor(Math.random() * blockShapes.length);			scoreLabel = createTextField("Your score:0");			levelLabel = createTextField("Level:0");			nextBlockLabel = createTextField("Next block");						// draw main layout			drawMainLayout();			// starting new game			newGame();		}		private function initializeValues():void {    		// allocate array for main data			values = new Array;			for (var i:Number = 0; i < col; ++i) {				var a:Array = new Array;				for (var j:Number = 0; j < row; ++j) {					a.push(0);				}				values.push(a);			}		}				private function initializeShapes():void {			blockShapes = new Array;			blockShapes.push(new TrBlocksShape1(this));			blockShapes.push(new TrBlocksShape2(this));			blockShapes.push(new TrBlocksShape3(this));			blockShapes.push(new TrBlocksShape4(this));			blockShapes.push(new TrBlocksShape5(this));			blockShapes.push(new TrBlocksShape6(this));			blockShapes.push(new TrBlocksShape7(this));		}		/********************************************** ITrGameData implements ********************************************************/				public function getCol():Number {			return col;		}				public function getRow():Number {			return row;		}				public function getValue(i:Number, j:Number):Number {			return values[i][j];		}				public function setValue(i:Number, j:Number, val:Number):void {			values[i][j] = val;		}						/********************************************** convert the position ********************************************************/				private function calcX(i:Number):Number {			return (i + 1) * blockDrawer.blockWidthPixels;		}		private function calcY(j:Number):Number {			return (j + 1) * blockDrawer.blockWidthPixels;		}				/********************************************** game related ********************************************************/		private function newGame():void {						score = 0;			totalRemovedLines = 0;			level = 1;			gameOver = false;			isPaused = false;						// zero all game zone			initializeValues();			// timer for droping blocks			timer = new Timer(1000);			timer.addEventListener(TimerEvent.TIMER, onDropBlocks);			timer.start();			// create the first droping blocks			newRandomBlocks();						refresh();		}				private function newRandomBlocks():void {			currentBlocks = blockShapes[nextBlockIndex];			nextBlockIndex = Math.floor(Math.random() * blockShapes.length);			currentBlocks.reset();			if (currentBlocks.isBlocking(currentBlocks.getI(), currentBlocks.getJ())) {				// game over				trace("Game over");				timer.stop();												gameOver = true;				showInfoText("Game over! Press any key to start a new game.");							} else {				currentBlocks.applyToGameData();			}		}				private function isLineFull(j:Number):Boolean {			for (var i:int = 0; i < getCol(); ++i) {				if (getValue(i, j) == 0) return false;			}			return true;		}				private function getFullLines():Array {			var lines:Array = new Array;			for (var j:int = 0; j < getRow(); ++j) {				if (isLineFull(j)) {					lines.push(j);				}			}			return lines;		}				private function emptyLine(indexOfLine:Number):void {			for (var col:int = 0; col < getCol(); ++col) {				values[col][indexOfLine] = 0;			}		}				private function copyLineFromAbove(indexOfLine:Number):void {			for (var col:int = 0; col < getCol(); ++col) {				values[col][indexOfLine] = values[col][indexOfLine - 1];			}		}				private function removeLine(indexOfLine:Number):void {			for (var row:int = indexOfLine; row > 0; --row) {				copyLineFromAbove(row);			}			emptyLine(0);		}				private function removeFullLines():void {			// remove lines			var lines:Array = getFullLines();			if (lines.length > 0) {								// yes, we have lines to remove				for (var i:int = 0; i < lines.length; ++i) {					removeLine(lines[i]);				}							}			// calculate score			var removedLines:uint = lines.length;			trace("removed:" + removedLines + " line(s)");						score += removedLines * removedLines * 10;			totalRemovedLines += removedLines;		}				/********************************************** flashing full line routines ********************************************************/				private function emptyFlashingLines():void {			for (var indexOfLine:int = 0; indexOfLine < flashingLines.length; ++indexOfLine) {				emptyLine(flashingLines[indexOfLine]);			}		}				private function restoreFlashingLines():void {			trace("flashingLinesValue.length=" + flashingLinesValue.length);			for (var indexOfLine:int = 0; indexOfLine < flashingLines.length; ++indexOfLine) {				for (var ii:int = 0; ii < getCol(); ++ii) {					values[ii][flashingLines[indexOfLine]] = flashingLinesValue[indexOfLine][ii];				}			}		}				private function saveFlashingLines():void {			flashingLinesValue = new Array;			for (var indexOfLine:int = 0; indexOfLine < flashingLines.length; ++indexOfLine) {				var savedLine:Array = new Array;				for (var ii:int = 0; ii < getCol(); ++ii) {					savedLine.push(values[ii][flashingLines[indexOfLine]]);				}				flashingLinesValue.push(savedLine);			}		}		private function flashAndRemoveFullLines():void {			// full line exists?			flashingLines = getFullLines();			if (flashingLines.length > 0) {				// have full lines				isFlashing = true;				timer.stop();				saveFlashingLines();				currentFlashIndex = 0;				flashingTimer = new Timer(100);				flashingTimer.addEventListener(TimerEvent.TIMER, onFlashing);				flashingTimer.start();			} else {				// next				newRandomBlocks();				refresh();			}		}				/********************************************** drawing functions ********************************************************/				private function setTextFormat(textField:TextField):void {			textField.height = 25;			textField.width = 170;			textField.selectable = false;			var textFormat:TextFormat = new TextFormat("Arial", 20, 0x000000);			textFormat.align = "center";			textField.setTextFormat(textFormat);		}				private function createTextField(text:String):TextField {			var textField:TextField = new TextField;			textField.text = text;			setTextFormat(textField);			addChild(textField);			return textField;		}				private function showInfoText(text:String):void {			infoLabel = createTextField(text);			infoLabel.textColor = 0xffffff;			infoLabel.width = 500;			infoLabel.x = (flashWidth - infoLabel.width) / 2;			infoLabel.y = 400;			addChild(infoLabel);		}				private function hideInfoText():void {			removeChild(infoLabel);		}				private var displaySizeOnFirstTime:Boolean = true;		private function drawMainLayout():void {						var zoneWidth:Number = col * blockDrawer.blockWidthPixels;			var zoneHeight:Number = row * blockDrawer.blockWidthPixels;						var panelWidth:Number = 200;						flashWidth = zoneWidth + blockDrawer.blockWidthPixels * 2 + panelWidth;			flashHeight = zoneHeight + blockDrawer.blockWidthPixels * 2;						trace('width=' + flashWidth + ", height=" + flashHeight);						// draw panel			var panelLeft:Number = zoneWidth + blockDrawer.blockWidthPixels * 2;			var panelTop:Number = blockDrawer.blockWidthPixels * 1;						if (displaySizeOnFirstTime) {								displaySizeOnFirstTime = false;				trace(flashWidth, flashHeight);								// set position of labels				scoreLabel.x = panelLeft;				scoreLabel.y = panelTop;								levelLabel.x = panelLeft;				levelLabel.y = panelTop + 40;								nextBlockLabel.x = panelLeft;				nextBlockLabel.y = panelTop + 150;			}									// outside			graphics.beginFill(0x666666);			graphics.drawRect(0, 0, flashWidth, flashHeight);			graphics.endFill();						// game zone			graphics.beginFill(0x000000);			graphics.drawRect(blockDrawer.blockWidthPixels, blockDrawer.blockWidthPixels, zoneWidth, zoneHeight);			graphics.endFill();						// next block			var nextBlocks:ITrBlocks = blockShapes[nextBlockIndex];			var leftMargin:Number = zoneWidth + blockDrawer.blockWidthPixels + (panelWidth + blockDrawer.blockWidthPixels - nextBlocks.getNumOfColsOfShape(0) * blockDrawer.blockWidthPixels) / 2;			for (var i:int = 0; i < nextBlocks.getNumOfColsOfShape(0); ++i)				for (var j:int = 0; j < nextBlocks.getNumOfRowsOfShape(0); ++j) {					var val:Number = nextBlocks.getValueOfShape(i, j, 0);					if (val > 0) {						var x:Number = i * blockDrawer.blockWidthPixels + leftMargin;						var y:Number = panelTop + 190 + j * blockDrawer.blockWidthPixels;						blockDrawer.drawBlock(x, y, val);					}				}		}				private function drawBlocks():void {			// blocks			for (var i:Number = 0; i < col; ++i)				for (var j:Number = 0; j < row; ++j) {					if (values[i][j] > 0) {						// draw block						blockDrawer.drawBlock(calcX(i), calcY(j), values[i][j]);					} else {						// erase						blockDrawer.eraseBlock(calcX(i), calcY(j));					}				}		}		private function refresh():void {			graphics.clear();			drawMainLayout();			drawBlocks();						// update labels			scoreLabel.text = "Your score:" + score;			setTextFormat(scoreLabel);			var calculatedLevel:Number = (Math.floor(totalRemovedLines / 10) + 1);			if (level != calculatedLevel) {				// increase the speed of dropping blocks				var msecs:Number = 1000 - (level * 0.1 * 1000);				trace("Dropping speed set to " + msecs + " (msec)");								// stop old timer				timer.stop();								// setup a new one				timer = new Timer(msecs);				timer.addEventListener(TimerEvent.TIMER, onDropBlocks);				timer.start();								// setup level				level = calculatedLevel;			}						levelLabel.text = "Level:" + level;			setTextFormat(levelLabel);					}		/********************************************** events ********************************************************/						private function onFlashing(e:TimerEvent):void {			if (currentFlashIndex < numberOfFlashTimes) {				if ((currentFlashIndex % 2) == 0) {					emptyFlashingLines();				} else {					restoreFlashingLines();				}				++currentFlashIndex;				refresh();			} else {				flashingTimer.stop();				// end				restoreFlashingLines();				removeFullLines();				newRandomBlocks();				timer.start();				isFlashing = false;				refresh();			}		}				private function onDropBlocks(e:TimerEvent):void {			if (currentBlocks.isBlocking(currentBlocks.getI(), currentBlocks.getJ() + 1)) {				// get to stable				currentBlocks.stableToGameData();				flashAndRemoveFullLines();			} else {				// droping				currentBlocks.removeFromGameData();				currentBlocks.IncJ();				currentBlocks.applyToGameData();				refresh();			}		}		private function onKeyLeftPressed():void {			if (gameOver || isPaused) return;			if (!currentBlocks.isBlocking(currentBlocks.getI() - 1, currentBlocks.getJ())) {				currentBlocks.removeFromGameData();				currentBlocks.DecI();				currentBlocks.applyToGameData();				refresh();			}		}				private function onKeyUpPressed():void {			if (gameOver || isPaused) return;			if (!currentBlocks.isBlockingOnNextTurn(currentBlocks.getI(), currentBlocks.getJ())) {				currentBlocks.removeFromGameData();				currentBlocks.turnRight();				currentBlocks.applyToGameData();				refresh();			} else {				// is blocking, find a place to rotate				var nextShapeNumOfCols:Number = currentBlocks.getNumOfColsOfShape(currentBlocks.getNextIndexOfShape());				var colsOutOfRange:Number = nextShapeNumOfCols + currentBlocks.getI() - getCol();				if (colsOutOfRange > 0) {					if (!currentBlocks.isBlockingOnNextTurn(currentBlocks.getI() - colsOutOfRange, currentBlocks.getJ())) {						currentBlocks.removeFromGameData();						currentBlocks.setI(currentBlocks.getI() - colsOutOfRange);						currentBlocks.turnRight();						currentBlocks.applyToGameData();						refresh();					}				}			}		}				private function onKeyRightPressed():void {			if (gameOver || isPaused) return;			if (!currentBlocks.isBlocking(currentBlocks.getI() + 1, currentBlocks.getJ())) {				currentBlocks.removeFromGameData();				currentBlocks.IncI();				currentBlocks.applyToGameData();				refresh();			}		}				private function onKeyDownPressed():void {			if (gameOver || isPaused) return;			currentBlocks.removeFromGameData();			while (!currentBlocks.isBlocking(currentBlocks.getI(), currentBlocks.getJ() + 1)) {				currentBlocks.IncJ();			}			currentBlocks.stableToGameData();			flashAndRemoveFullLines();		}				private function onKeyPressed(e:KeyboardEvent):void {			if (isFlashing) return;						if (e.keyCode == 37) onKeyLeftPressed();			else if (e.keyCode == 38) onKeyUpPressed();			else if (e.keyCode == 39) onKeyRightPressed();			else if (e.keyCode == 40) onKeyDownPressed();			else {				// other key				if (gameOver) {					// new game					hideInfoText();					newGame();				} else {					// pause					if (!isPaused) {						timer.stop();						isPaused = true;						showInfoText("Game paused, press any key to resume.");					} else {						hideInfoText();						timer.start();						isPaused = false;					}				}			}		}					}	}