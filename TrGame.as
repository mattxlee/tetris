package  {		import flash.display.MovieClip;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;			public class TrGame extends MovieClip {				// number of columns and rows		private var col: Number = 10;		private var row: Number = 20;		private var values: Array;				// preferenes of pixels		private var blockWidthPixels: Number = 20;		private var borderWidthPixels: Number = 10;				// timer for droping blocks		private var timer: Timer;				private var currentBlocks: ITrBlocks;		private var currentBlocksI: Number;		private var currentBlocksJ: Number;				private var blockShapes: Array;				public function TrGame() {			// constructor code			    		// allocate array for main data			values = new Array;			for (var i: Number = 0; i < col; ++i) {				var a: Array = new Array;				for (var j: Number = 0; j < row; ++j) {					a.push(0);				}				values.push(a);			}						// timer for droping blocks			timer = new Timer(1000);			timer.addEventListener(TimerEvent.TIMER, onDropingBlocks);			timer.start();						// keyboard event receiver			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);						var zoneWidth: Number = col * blockWidthPixels;			var zoneHeight: Number = row * blockWidthPixels;						var width = zoneWidth + borderWidthPixels * 2;			var height = zoneHeight + borderWidthPixels * 2;			trace("width=", width, ", height=", height);						// draw			graphics.lineStyle(1, 0x000000);						// outside			graphics.drawRect(0, 0, width, height);						// inside			graphics.drawRect(borderWidthPixels, borderWidthPixels, zoneWidth, zoneHeight);						blockShapes = new Array;			blockShapes.push(new TrBlocksShape1);			blockShapes.push(new TrBlocksShape2);			blockShapes.push(new TrBlocksShape3);			blockShapes.push(new TrBlocksShape4);			blockShapes.push(new TrBlocksShape5);			blockShapes.push(new TrBlocksShape6);			blockShapes.push(new TrBlocksShape7);						// create the first droping blocks			newRandomBlocks();						refresh();		}				private function newRandomBlocks() {			//currentBlocks = new TrBlocksShape1;			var index = Math.floor(Math.random() * blockShapes.length);			currentBlocks = blockShapes[index];			currentBlocksI = currentBlocksJ = 0;		}				private function willBeStableOnNextDrop(newI: Number, newJ: Number) {			if (newJ + currentBlocks.getNumOfRows() > row) return true;			for (var i: Number = 0; i < currentBlocks.getNumOfCols(); ++i) {				for (var j: Number = 0; j < currentBlocks.getNumOfRows(); ++j) {					if (currentBlocks.getValue(i, j) != 0) {						// non-empty block						if (values[newI + i][newJ + j] == 100) {							return true;						}					}				}			}						return false;		}				private function changeCurrentBlocksToStable() {			for (var i: Number = 0; i < col; ++i) {				for (var j: Number = 0; j < row; ++j) {					if (values[i][j] > 0) {						values[i][j] = 100;					}				}			}		}				private function removeFullLines() {			// remove full lines			for (var j = 0; j < row; ++j) {				var full = true;				for (var i = 0; i < col; ++i) {					if (values[i][j] != 100) full = false;				}								if (full) {					// yes, remove current line = j					for (var jj = j; jj >= 0; --jj) {						for (var i2 = 0; i2 < col; ++i2) {							values[i2][jj] = values[i2][jj - 1];						}					}				}			}					}				private function dropCurrentBlocks() {						removeFullLines();						if (willBeStableOnNextDrop(currentBlocksI, currentBlocksJ + 1)) {				// get to stable				changeCurrentBlocksToStable();								// next one				newRandomBlocks();			} else {				// droping				++currentBlocksJ;			}						refresh();		}				private function onDropingBlocks(e: TimerEvent) {			dropCurrentBlocks();		}				private function eraseUnstableArea() {			var totalErased = 0;			for (var i: Number = 0; i < col; ++i)				for (var j: Number = 0; j < row; ++j) {					if (values[i][j] != 100) {						values[i][j] = 0;						eraseBlock(i, j);						++totalErased;					}				}		}				private function applyCurrentBlocks() {			var totalDrawed = 0;			for (var i: Number = 0; i < currentBlocks.getNumOfCols(); ++i) {				for (var j: Number = 0; j < currentBlocks.getNumOfRows(); ++j) {					var val = currentBlocks.getValue(i, j);					if (val > 0 && val < 100) {						values[currentBlocksI + i][currentBlocksJ + j] = currentBlocks.getValue(i, j);						drawBlock(currentBlocksI + i, currentBlocksJ + j);						++totalDrawed;					}				}							}		}				//		// four arrow keys events		//				private function onKeyLeftPressed() {			if (currentBlocksI > 0) {				if (!willBeStableOnNextDrop(currentBlocksI - 1, currentBlocksJ)) {					--currentBlocksI;					refresh();				}			}		}				private function onKeyUpPressed() {			var shapeArray = currentBlocks.getNextRightShape();						// right border check			if (shapeArray[0].length + currentBlocksI > col) {				return;			}						// current blocks check			for (var i = 0; i < shapeArray[0].length; ++i) {				for (var j = 0; j < shapeArray.length; ++j) {					if (shapeArray[j][i] != 0 && values[i + currentBlocksI][j + currentBlocksJ] == 100) {						return;					}				}			}			currentBlocks.turnRight();			refresh();		}				private function onKeyRightPressed() {			if (currentBlocksI + currentBlocks.getNumOfCols() < col) {				if (!willBeStableOnNextDrop(currentBlocksI + 1, currentBlocksJ)) {					++currentBlocksI;					refresh();				}			}		}				private function onKeyDownPressed() {			dropCurrentBlocks();		}				//		// end of four arrow keys events		//				private function onKeyPressed(e: KeyboardEvent) {			if (e.keyCode == 37) onKeyLeftPressed();			else if (e.keyCode == 38) onKeyUpPressed();			else if (e.keyCode == 39) onKeyRightPressed();			else if (e.keyCode == 40) onKeyDownPressed();		}						private function refresh() {			graphics.clear();			eraseUnstableArea();			applyCurrentBlocks();			// calculate the width and height in pixels			var zoneWidth: Number = col * blockWidthPixels;			var zoneHeight: Number = row * blockWidthPixels;						var width = zoneWidth + borderWidthPixels * 2;			var height = zoneHeight + borderWidthPixels * 2;						// draw			graphics.lineStyle(1, 0x000000);						// outside			graphics.drawRect(0, 0, width, height);						// inside			graphics.drawRect(borderWidthPixels, borderWidthPixels, zoneWidth, zoneHeight);						// blocks			for (var i: Number = 0; i < col; ++i)				for (var j: Number = 0; j < row; ++j) {					if (getValue(i, j) > 0) {						// draw block						if (getValue(i, j) == 100) {							// stable blocks							graphics.lineStyle(1, 0xff0000);						} else {							// dropping blocks							graphics.lineStyle(1, 0x000000);						}						drawBlock(i, j);					} else {						eraseBlock(i, j);					}				}		}				private function getValue(i: Number, j: Number) {			return values[i][j];		}				private function drawBlock(i: Number, j: Number) {						var x, y: Number;			x = i * blockWidthPixels + borderWidthPixels;			y = j * blockWidthPixels + borderWidthPixels;						// draw block			graphics.drawRect(x + 1, y + 1, blockWidthPixels - 2, blockWidthPixels - 2);		}				private function eraseBlock(i: Number, j: Number) {			var x, y: Number;			x = i * blockWidthPixels + borderWidthPixels;			y = j * blockWidthPixels + borderWidthPixels;						// draw block			graphics.lineStyle(1, 0xffffff);			graphics.drawRect(x + 1, y + 1, blockWidthPixels - 2, blockWidthPixels - 2);		}	}	}