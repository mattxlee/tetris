package  {		import flash.display.MovieClip;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;		import flash.text.TextField;	import flash.text.TextFormat;		public class TrGame extends MovieClip implements ITrGameData {				// number of columns and rows		private var col: Number = 10;		private var row: Number = 20;		private var values: Array;		private var nextBlockIndex: Number;				// scores and etc.		private var score: Number = 0;		private var totalRemovedLines: Number = 0;		private var level: Number = 1;				private var blockDrawer: TrBlockDrawer;		private var currentBlocks: ITrBlocks;		// timer for droping blocks		private var timer: Timer;				// all shapes we have, class of TrAbstractBlocks		private var blockShapes: Array;				// text fields		private var scoreLabel: TextField;		private var levelLabel: TextField;		private var nextBlockLabel: TextField;				/********************************************** constructor and initializators ********************************************************/				public function TrGame() {									blockDrawer = new TrBlockDrawer(graphics);						// 7 shapes			initializeShapes();			nextBlockIndex = Math.floor(Math.random() * blockShapes.length);			scoreLabel = createTextField("Your score: 0");			levelLabel = createTextField("Level: 0");			nextBlockLabel = createTextField("Next block");			// draw main layout			drawMainLayout();			// starting new game			newGame();		}		private function initializeValues() {    		// allocate array for main data			values = new Array;			for (var i: Number = 0; i < col; ++i) {				var a: Array = new Array;				for (var j: Number = 0; j < row; ++j) {					a.push(0);				}				values.push(a);			}		}				private function initializeShapes() {			blockShapes = new Array;			blockShapes.push(new TrBlocksShape1(this));			blockShapes.push(new TrBlocksShape2(this));			blockShapes.push(new TrBlocksShape3(this));			blockShapes.push(new TrBlocksShape4(this));			blockShapes.push(new TrBlocksShape5(this));			blockShapes.push(new TrBlocksShape6(this));			blockShapes.push(new TrBlocksShape7(this));		}		/********************************************** ITrGameData implements ********************************************************/				public function getCol() {			return col;		}				public function getRow() {			return row;		}				public function getValue(i: Number, j: Number) {			return values[i][j];		}				public function setValue(i: Number, j: Number, val: Number) {			values[i][j] = val;		}						/********************************************** convert the position ********************************************************/				private function calcX(i: Number) {			return (i + 1) * blockDrawer.blockWidthPixels;		}		private function calcY(j: Number) {			return (j + 1) * blockDrawer.blockWidthPixels;		}				/********************************************** game related ********************************************************/		private function newGame() {						score = 0;			totalRemovedLines = 0;			level = 1;						// zero all game zone			initializeValues();			// keyboard event receiver			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);			// timer for droping blocks			timer = new Timer(1000);			timer.addEventListener(TimerEvent.TIMER, onDropBlocks);			timer.start();			// create the first droping blocks			newRandomBlocks();						refresh();		}				private function newRandomBlocks() {			currentBlocks = blockShapes[nextBlockIndex];			nextBlockIndex = Math.floor(Math.random() * blockShapes.length);			currentBlocks.reset();			if (currentBlocks.isBlocking(currentBlocks.getI(), currentBlocks.getJ())) {				// game over				trace("Game over");				timer.stop();												stage.removeEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);							} else {				currentBlocks.applyToGameData();			}		}				private function removeFullLines() {						var removedLines = 0;						// remove full lines			for (var j = 0; j < row; ++j) {				var full = true;				for (var i = 0; i < col; ++i) {					if (values[i][j] <= 100) full = false;				}								if (full) {					// yes, remove current line = j					++removedLines;										for (var jj = j; jj >= 0; --jj) {						for (var i2 = 0; i2 < col; ++i2) {							values[i2][jj] = values[i2][jj - 1];						}					}				}			}						score += removedLines * removedLines * 10;			totalRemovedLines += removedLines;					}				/********************************************** drawing functions ********************************************************/				private function setTextFormat(textField: TextField) {			textField.height = 25;			textField.width = 170;			textField.selectable = false;			var textFormat:TextFormat = new TextFormat("Arial", 20, 0xffffff);			textFormat.align = "right";			textField.setTextFormat(textFormat);		}				private function createTextField(text: String) {			var textField:TextField = new TextField;			textField.text = text;			setTextFormat(textField);			addChild(textField);			return textField;		}				private var displaySizeOnFirstTime = true;		private function drawMainLayout() {						var zoneWidth: Number = col * blockDrawer.blockWidthPixels;			var zoneHeight: Number = row * blockDrawer.blockWidthPixels;						var panelWidth = 200;						var width = zoneWidth + blockDrawer.blockWidthPixels * 2 + panelWidth;			var height = zoneHeight + blockDrawer.blockWidthPixels * 2;						// draw panel			var panelLeft = zoneWidth + blockDrawer.blockWidthPixels * 2;			var panelTop = blockDrawer.blockWidthPixels * 1;						if (displaySizeOnFirstTime) {								displaySizeOnFirstTime = false;				trace(width, height);								// set position of labels				scoreLabel.x = panelLeft;				scoreLabel.y = panelTop;								levelLabel.x = panelLeft;				levelLabel.y = panelTop + 40;								nextBlockLabel.x = panelLeft;				nextBlockLabel.y = panelTop + 150;			}									// outside			graphics.beginFill(0x333333);			graphics.drawRect(0, 0, width, height);			graphics.endFill();						// game zone			graphics.beginFill(0x000000);			graphics.drawRect(blockDrawer.blockWidthPixels, blockDrawer.blockWidthPixels, zoneWidth, zoneHeight);			graphics.endFill();						// next block			var nextBlocks:ITrBlocks = blockShapes[nextBlockIndex];			var leftMargin = width - (nextBlocks.getNumOfColsOfShape(0) * blockDrawer.blockWidthPixels) - blockDrawer.blockWidthPixels;			for (var i = 0; i < nextBlocks.getNumOfColsOfShape(0); ++i)				for (var j = 0; j < nextBlocks.getNumOfRowsOfShape(0); ++j) {					var val = nextBlocks.getValueOfShape(i, j, 0);					if (val > 0) {						var x = i * blockDrawer.blockWidthPixels + leftMargin;						var y = panelTop + 190 + j * blockDrawer.blockWidthPixels;						blockDrawer.drawBlock(x, y, val);					}				}		}				private function drawBlocks() {			// blocks			for (var i: Number = 0; i < col; ++i)				for (var j: Number = 0; j < row; ++j) {					if (values[i][j] > 0) {						// draw block						blockDrawer.drawBlock(calcX(i), calcY(j), values[i][j]);					} else {						// erase						blockDrawer.eraseBlock(calcX(i), calcY(j));					}				}		}		private function refresh() {			graphics.clear();			drawMainLayout();			drawBlocks();						// update labels			scoreLabel.text = "Your score: " + score;			setTextFormat(scoreLabel);			var calculatedLevel = (Math.floor(totalRemovedLines / 10) + 1);			if (level != calculatedLevel) {				// increase the speed of dropping blocks				var msecs = 1000 - (level * 0.1 * 1000);				trace("Dropping speed set to " + msecs + " (msec)");								// stop old timer				timer.stop();								// setup a new one				timer = new Timer(msecs);				timer.addEventListener(TimerEvent.TIMER, onDropBlocks);				timer.start();								// setup level				level = calculatedLevel;			}						levelLabel.text = "Level: " + level;			setTextFormat(levelLabel);					}		/********************************************** events ********************************************************/				private function onDropBlocks(e: TimerEvent) {			if (currentBlocks.isBlocking(currentBlocks.getI(), currentBlocks.getJ() + 1)) {				// get to stable				currentBlocks.stableToGameData();				removeFullLines();								// next one				newRandomBlocks();			} else {				// droping				currentBlocks.removeFromGameData();				currentBlocks.IncJ();				currentBlocks.applyToGameData();			}						refresh();		}		private function onKeyLeftPressed() {			if (!currentBlocks.isBlocking(currentBlocks.getI() - 1, currentBlocks.getJ())) {				currentBlocks.removeFromGameData();				currentBlocks.DecI();				currentBlocks.applyToGameData();				refresh();			}		}				private function onKeyUpPressed() {			if (!currentBlocks.isBlockingOnNextTurn(currentBlocks.getI(), currentBlocks.getJ())) {				currentBlocks.removeFromGameData();				currentBlocks.turnRight();				currentBlocks.applyToGameData();				refresh();			}		}				private function onKeyRightPressed() {			if (!currentBlocks.isBlocking(currentBlocks.getI() + 1, currentBlocks.getJ())) {				currentBlocks.removeFromGameData();				currentBlocks.IncI();				currentBlocks.applyToGameData();				refresh();			}		}				private function onKeyDownPressed() {			// find until it is blocking			currentBlocks.removeFromGameData();			while (!currentBlocks.isBlocking(currentBlocks.getI(), currentBlocks.getJ() + 1)) {				currentBlocks.IncJ();			}			currentBlocks.stableToGameData();			removeFullLines();			newRandomBlocks();			refresh();		}				private function onKeyPressed(e: KeyboardEvent) {			if (e.keyCode == 37) onKeyLeftPressed();			else if (e.keyCode == 38) onKeyUpPressed();			else if (e.keyCode == 39) onKeyRightPressed();			else if (e.keyCode == 40) onKeyDownPressed();		}					}	}