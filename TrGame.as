package  {		import flash.display.MovieClip;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;			public class TrGame extends MovieClip {				// number of columns and rows		private var col: Number = 10;		private var row: Number = 20;		private var values: Array;				// preferenes of pixels		private var blockWidthPixels: Number = 20;		private var borderWidthPixels: Number = 10;				// timer for droping blocks		private var timer: Timer;				private var currentBlocks: ITrBlocks;		private var currentBlocksI: Number;		private var currentBlocksJ: Number;				public function TrGame() {			// constructor code						trace("Hello world");			// allocate array for main data			values = new Array;			for (var i: Number = 0; i < col; ++i) {				var a: Array = new Array;				for (var j: Number = 0; j < row; ++j) {					a.push(0);				}				values.push(a);			}						// timer for droping blocks			timer = new Timer(1000);			timer.addEventListener(TimerEvent.TIMER, onDropingBlocks);			timer.start();						// keyboard event receiver			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyPressed);						currentBlocks = new TrBlocksShape1;						// create the first droping blocks			newRandomBlocks();						refresh();		}				private function newRandomBlocks() {			//currentBlocks = new TrBlocksShape1;			currentBlocksI = currentBlocksJ = 0;		}				private function willBeStableOnNextDrop(newI: Number, newJ: Number) {			if (newJ + currentBlocks.getNumOfRows() > row) return true;			for (var i: Number = 0; i < currentBlocks.getNumOfCols(); ++i) {				for (var j: Number = 0; j < currentBlocks.getNumOfRows(); ++j) {					if (currentBlocks.getValue(i, j) != 0) {						// non-empty block						if (values[newI + i][newJ + j] == 100) {							return true;						}					}				}			}						return false;		}				private function changeCurrentBlocksToStable() {			for (var i: Number = 0; i < col; ++i) {				for (var j: Number = 0; j < row; ++j) {					if (values[i][j] > 0) {						values[i][j] = 100;					}				}			}		}				private function dropCurrentBlocks() {			if (willBeStableOnNextDrop(currentBlocksI, currentBlocksJ + 1)) {				trace("stable current blocks");								// get to stable				changeCurrentBlocksToStable();								// next one				newRandomBlocks();							} else {				trace("drop 1");				// droping				++currentBlocksJ;			}						refresh();		}				private function onDropingBlocks(e: TimerEvent) {			dropCurrentBlocks();		}				private function eraseUnstableArea() {			for (var i: Number = 0; i < col; ++i)				for (var j: Number = 0; j < row; ++j) {					if (values[i][j] != 100) {						values[i][j] = 0;					}				}		}				private function applyCurrentBlocks() {			for (var i: Number = 0; i < currentBlocks.getNumOfCols(); ++i) {				for (var j: Number = 0; j < currentBlocks.getNumOfRows(); ++j) {					if (currentBlocks.getValue(i, j) != 0) {						values[currentBlocksI + i][currentBlocksJ + j] = currentBlocks.getValue(i, j);					}				}							}		}				//		// four arrow keys events		//				private function onKeyLeftPressed() {			if (currentBlocksI > 0) {				if (!willBeStableOnNextDrop(currentBlocksI - 1, currentBlocksJ)) {					--currentBlocksI;					refresh();										trace("left");				}			}		}				private function onKeyUpPressed() {			currentBlocks.turnRight();			refresh();		}				private function onKeyRightPressed() {			if (currentBlocksI + currentBlocks.getNumOfCols() < col) {				if (!willBeStableOnNextDrop(currentBlocksI + 1, currentBlocksJ)) {					++currentBlocksI;					refresh();										trace("right");				}			}		}				private function onKeyDownPressed() {			dropCurrentBlocks();		}				//		// end of four arrow keys events		//				private function onKeyPressed(e: KeyboardEvent) {			if (e.keyCode == 37) onKeyLeftPressed();			else if (e.keyCode == 38) onKeyUpPressed();			else if (e.keyCode == 39) onKeyRightPressed();			else if (e.keyCode == 40) onKeyDownPressed();		}						private function refresh() {			eraseUnstableArea();			applyCurrentBlocks();			// calculate the width and height in pixels			var zoneWidth: Number = col * blockWidthPixels;			var zoneHeight: Number = row * blockWidthPixels;						var width = zoneWidth + borderWidthPixels * 2;			var height = zoneHeight + borderWidthPixels * 2;						// draw			graphics.lineStyle(1, 0x000000);						// outside			graphics.drawRect(0, 0, width, height);						// inside			graphics.drawRect(borderWidthPixels, borderWidthPixels, zoneWidth, zoneHeight);						// blocks			for (var i: Number = 0; i < col; ++i)				for (var j: Number = 0; j < row; ++j) {					if (getValue(i, j) > 0) {						// draw block						if (getValue(i, j) == 100) {							// stable blocks							graphics.lineStyle(1, 0xff0000);						} else {							// dropping blocks							graphics.lineStyle(1, 0x000000);						}						drawBlock(i, j);					} else {						eraseBlock(i, j);					}				}		}				private function getValue(i: Number, j: Number) {			return values[i][j];		}				private function drawBlock(i: Number, j: Number) {			var x, y: Number;			x = i * blockWidthPixels + borderWidthPixels;			y = j * blockWidthPixels + borderWidthPixels;						// draw block			graphics.drawRect(x + 1, y + 1, blockWidthPixels - 2, blockWidthPixels - 2);		}				private function eraseBlock(i: Number, j: Number) {			var x, y: Number;			x = i * blockWidthPixels + borderWidthPixels;			y = j * blockWidthPixels + borderWidthPixels;						// draw block			graphics.lineStyle(1, 0xffffff);			graphics.drawRect(x + 1, y + 1, blockWidthPixels - 2, blockWidthPixels - 2);		}	}	}